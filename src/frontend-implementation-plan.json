{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fast fail startup fallback for slow-but-reachable backend",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Fail fast during startup when actor creation/profile load is slow but backend is reachable, showing StartupErrorScreen within a shorter configurable timeout instead of waiting 45s.",
      "acceptanceCriteria": [
        "When authenticated and the backend is slow, the app shows an actionable error screen within a shorter, configurable timeframe (<= 15 seconds) rather than waiting the full STARTUP_TIMEOUT_MS (45s).",
        "The error screen clearly indicates that the backend is reachable but responding slowly (based on health check), and offers Retry Connection and Logout actions.",
        "The app does not remain indefinitely on a loading screen (\"Connecting to backend...\" or \"Loading your profile...\") in any of the startup paths."
      ],
      "file_operations": [
        {
          "path": "frontend/src/lib/startupTimings.ts",
          "operation": "create",
          "description": "Add centralized, configurable startup timing constants (e.g., FAIL_FAST_MS <= 15000, HEALTHCHECK_EARLY_TRIGGER_MS <= 5000, PROFILE_STARTUP_TIMEOUT_MS <= 15000, ACTOR_CREATE_TIMEOUT_MS <= 15000) so startup behavior can be tuned without hunting through files."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Update startup state machine to support a fail-fast timeout distinct from the existing 45s watchdog: (1) track a short fail-fast timer during authenticated startup loading, (2) if backend reachability is confirmed (health check success) while actor/profile is still pending, transition to StartupErrorScreen when the short timer elapses, and (3) update the timeout-screen messaging to explicitly state \"backend reachable but responding slowly\" when health check succeeded; keep Retry Connection and Logout actions wired to existing handlers."
        },
        {
          "path": "frontend/src/hooks/useResilientActor.ts",
          "operation": "modify",
          "description": "Reduce and/or parameterize actor creation timeout using the new startup timing constants so slow actor creation fails within the configured fail-fast window (<= 15s) and naturally triggers the existing actor error UI flow; keep error normalization behavior intact."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Add explicit per-step timeouts (via withTimeout) to startup-critical calls like getCallerUserProfile so hangs resolve quickly into existing error handling and Retry resets state.",
      "acceptanceCriteria": [
        "The startup profile query (useGetCallerUserProfileStartup) times out and transitions to the Profile Load Failed error state within a defined timeout (<= 10–15 seconds) if the call does not resolve.",
        "Timeout errors are normalized into user-facing messages consistent with existing error handling (normalizeError patterns).",
        "Retry Connection from the error screen resets the timed-out state and re-attempts actor creation and profile load."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Wrap startup profile fetch (actor.getCallerUserProfile) in withTimeout using the configured startup profile timeout (<= 10–15s); on timeout (or other errors), normalize via existing normalizeError patterns so App.tsx lands in the existing \"Profile Load Failed\" flow consistently."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Ensure Retry Connection fully resets any new fail-fast/timeout state introduced for startup (in addition to existing query removals/refetch) so actor creation and profile load are re-attempted cleanly after a timeout-triggered error."
        },
        {
          "path": "frontend/src/lib/startupTimings.ts",
          "operation": "modify",
          "description": "Add/adjust constants for per-step startup timeouts (profile fetch timeout, actor creation timeout) to satisfy the <=10–15s acceptance criteria and keep them aligned across hooks and startup UI logic."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Trigger performHealthCheck earlier during startup when loading exceeds a short threshold, so the UI can distinguish unreachable vs reachable-but-slow without waiting for errors/timeouts.",
      "acceptanceCriteria": [
        "During startup loading, if actor/profile is still pending beyond a short threshold (<= 5 seconds), the app triggers performHealthCheck in the background (without blocking UI).",
        "If the health check succeeds while startup is still pending, the app uses that reachability signal to drive the faster fallback behavior and messaging.",
        "Health check calls remain protected by the existing timeouts in performHealthCheck and do not introduce new infinite waits."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Add an early-startup background health check trigger: when authenticated and actor/profile are still pending beyond the configured threshold (<= 5s), call performHealthCheck without blocking the UI; store the result so the app can label states as \"reachable but slow\" vs \"unreachable\" and use that signal for fail-fast behavior."
        },
        {
          "path": "frontend/src/lib/startupTimings.ts",
          "operation": "modify",
          "description": "Define/adjust the early health-check trigger threshold constant (<= 5000ms) used by App.tsx to start performHealthCheck during slow startup, while leaving performHealthCheck's internal timeouts unchanged."
        },
        {
          "path": "frontend/src/lib/startupDiagnostics.ts",
          "operation": "modify",
          "description": "Harden performHealthCheck integration for repeated/early calls (idempotent usage expectations): ensure call sites can safely invoke it during startup without introducing any new infinite waits, relying on the existing Promise.race timeouts already present."
        }
      ]
    }
  ]
}